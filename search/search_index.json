{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to koil What is it? koil is an opinionated, full-stack template for building server-rendered applications in Kotlin without sacrificing the developer experience provided by modern front-end tooling. koil comes out-of-the-box with everything you need to launch your rich web application in hours rather than weeks. We include: authentication workflows (including password reset emails, registration and more); live-reload in development; CSS pre-processors; Typescript; a core set of common StimulusJS controllers required for basic reactivity; rich example-driven documentation (everything from making a change, to writing the test, to running in production); production deployment niceties (including caching of static assets with hashed names); and more. If there's something you think we're missing, then open an issue on the github. Who is this for? When starting Happy Valley IO there were definite gaps in our knowledge. Coming from corporate backgrounds, we hadn't really needed to deal with a bunch of the fixed up-front setup that working on a small team (or as a solo developer) requires. I mean, how often do you have to re-build the password reset emails? We based the tech choices we've made in koil around our imagined typical JVM developer who's trying to launch a SaaS product in their spare time, or starting their own company. A developer who is very comfortable working in a standard Spring Boot setup and knows enough front-end to build a great user experience without necessarily being an expert in how modern front-end build pipelines work. That's not to say that it won't work well in a larger org, but we're not building with them in mind. This is a tool for users who love Spring Boot, who love working on the JVM, who love simple production infrastructure, and who want to deploy their product now . This is a tool for Java/Kotlin developers who look at Ruby on Rails devs with a little bit of envy. We're not optimizing for technical purity here, but for Getting Shit Done. Effectively, this is what we wish we'd had available when we left corporate life. Why is it better than the alternatives? While we've historically embraced the vogue in tech (spinning up JSON API's that powered SPA front-ends), we've come to the conclusion that we can do something simpler without giving up user or developer experience. To be honest, we've found it's easier to have fast, bug-free front-end code without large javascript bundles. We believe that we're cherry-picking the best of two worlds in koil: we have the JVM as our main runtime platform, giving us great performance, great stability and a terrific eco-system to leverage; we have a Node.js based build pipeline for our front-end, allowing us to leverage great tools like Typescript, SASS and best-in-class asset bundling to have the best developer experience possible. In this way, we can take advantage of the best parts of building a traditional monolithic MPA (initial load performance, amazing editor integration for view-models, easy deployment, etc.) without sacrificing the awesome tools that we've loved using while working on SPA's in Vue or React. What's more, there no reason that you can't use these frameworks in koil. We just think you'll be happy to kick things off without them :). Why are you releasing this for free? Through open source all things are possible - so jot that down. We've benefited tremendously from open source, and we want to give back. From a business perspective, we will only benefit from marketing of our core consulting business with the free version but we are planning on releasing a premium licensed version with additional features later this year.","title":"Welcome to koil"},{"location":"#welcome-to-koil","text":"","title":"Welcome to koil"},{"location":"#what-is-it","text":"koil is an opinionated, full-stack template for building server-rendered applications in Kotlin without sacrificing the developer experience provided by modern front-end tooling. koil comes out-of-the-box with everything you need to launch your rich web application in hours rather than weeks. We include: authentication workflows (including password reset emails, registration and more); live-reload in development; CSS pre-processors; Typescript; a core set of common StimulusJS controllers required for basic reactivity; rich example-driven documentation (everything from making a change, to writing the test, to running in production); production deployment niceties (including caching of static assets with hashed names); and more. If there's something you think we're missing, then open an issue on the github.","title":"What is it?"},{"location":"#who-is-this-for","text":"When starting Happy Valley IO there were definite gaps in our knowledge. Coming from corporate backgrounds, we hadn't really needed to deal with a bunch of the fixed up-front setup that working on a small team (or as a solo developer) requires. I mean, how often do you have to re-build the password reset emails? We based the tech choices we've made in koil around our imagined typical JVM developer who's trying to launch a SaaS product in their spare time, or starting their own company. A developer who is very comfortable working in a standard Spring Boot setup and knows enough front-end to build a great user experience without necessarily being an expert in how modern front-end build pipelines work. That's not to say that it won't work well in a larger org, but we're not building with them in mind. This is a tool for users who love Spring Boot, who love working on the JVM, who love simple production infrastructure, and who want to deploy their product now . This is a tool for Java/Kotlin developers who look at Ruby on Rails devs with a little bit of envy. We're not optimizing for technical purity here, but for Getting Shit Done. Effectively, this is what we wish we'd had available when we left corporate life.","title":"Who is this for?"},{"location":"#why-is-it-better-than-the-alternatives","text":"While we've historically embraced the vogue in tech (spinning up JSON API's that powered SPA front-ends), we've come to the conclusion that we can do something simpler without giving up user or developer experience. To be honest, we've found it's easier to have fast, bug-free front-end code without large javascript bundles. We believe that we're cherry-picking the best of two worlds in koil: we have the JVM as our main runtime platform, giving us great performance, great stability and a terrific eco-system to leverage; we have a Node.js based build pipeline for our front-end, allowing us to leverage great tools like Typescript, SASS and best-in-class asset bundling to have the best developer experience possible. In this way, we can take advantage of the best parts of building a traditional monolithic MPA (initial load performance, amazing editor integration for view-models, easy deployment, etc.) without sacrificing the awesome tools that we've loved using while working on SPA's in Vue or React. What's more, there no reason that you can't use these frameworks in koil. We just think you'll be happy to kick things off without them :).","title":"Why is it better than the alternatives?"},{"location":"#why-are-you-releasing-this-for-free","text":"Through open source all things are possible - so jot that down. We've benefited tremendously from open source, and we want to give back. From a business perspective, we will only benefit from marketing of our core consulting business with the free version but we are planning on releasing a premium licensed version with additional features later this year.","title":"Why are you releasing this for free?"},{"location":"deploy/heroku/","text":"Deploying to Heroku Heroku is a PaaS product that makes deploying your application easy. With its generous free tier it's a perfect way to kick off a new project. It's easy to deploy a koil application with Heroku. We can also benefit tremendously from the Heroku add-on ecosystem: mailgun as an SMTP server to send emails; sentry for error-tracking; logdna for log aggregation; and hosted postgresql as a data store. You can check the other add-ons heroku comes with out of the box here . Minimum Viable Deployment There are a couple of ways that we can deploy to Heroku - they maintain excellent docs on this here . The deployment mechanism we'll be focusing on is the GitHub integration. We'll be building out a production-ready pipeline here. We'll connect our app to a koil based GitHub repo and deploy the application with a database. One of the primary benefits to working in koil is simplicity of building and deploying. It's a single, stateless JVM instance that's connected to a database. Most of the tricky first-time setup has already been done in the gradle build scripts. As such, anything that can deploy a Spring Boot project can deploy a koil project without difficulty. As it happens, Heroku has terrific integration with Spring Boot so deploying a live, production-ready application is pretty simple. I'm going to presume you've signed up to a Heroku account, if you haven't then do so , login to the Heroku dashboard and get ready to go. Step 1: Create a Heroku App If you've just signed up to Heroku you'll be presented with an empty dashboard. On this page, click the New button and select App . This will take you to the create application page: When there, fill in the details for your application and hit Create App . This will take you on to your new app page: Hooray! An app is born! Step 2: Create a pipeline and deploy Now, our app doesn't actually do anything yet. Let's fix that. You'll be prompted to add this app to a pipeline at the top of the page. Click to create a new pipeline and fill in the details: This will forward you on to the newly created pipeline: When here, click the prompt to Connect to Github . If you don't see this prompt, then navigate to the Settings tab. Once on this page, search for your GitHub repo then connect. While you're here, I'd really recommend enabling review apps . You can see the settings we recommend in the image below: They'll give you a great way to interact with pull request changes before merging. koil comes with an app.json file configured that specifies the required postgres database for your review apps. If you'd like to add other addons for each review app, then you can do so by modifying app.json . Heroku will respect the changes on the next deploy. Step 3: Enable automatic deploys Navigate back to the Pipeline tab to see the new setup. We'll add a staging environment here later. For now, let's enable automatic deploys. Click the menu toggle button on the production app. And click Configure automatic deploys... . You'll be presented with some options. We recommend deploying master only after CI passes. And we're set! This means that the next time we merge into master we'll see our application automatically updated! Step 4: Making a change Let's make a tiny change. I've added a new empty line between two tags in src/webapp/src/templates/pages/index.peb . You could do something more dramatic here of course. Commit this change on a feature branch feature/example and push to github. Now go to your repo in the browser and you'll be prompted to open a pull-request. Click the Compare & pull request... button, fill out the form on this page and then create the pull request. Alright! Now go make a cup of coffee while the CI build runs. koil has a longer build than a base Spring Boot project, but we promise it's worth it. Right now GitHub is running unit, integration and feature tests on the back-end and has kicked off Cypress to test your front-end. Once it's done, you should see something like this: Click the View deployment button and... Ta-da! Our review app is live! This has its own Heroku Postgres instance spun up, so we can play around with it without impacting a shared database. Note: we've still not finished the setup for our production app yet - read on to finish the required setup. Step 5: Merging to master and deploying to production Now we've done some QA on our review app, we'll merge the pull request and deploy to production. Normally, this is where a teammate would review our change, but for now we can safely click the Merge button and carry on solo. Upon merging the pull request, the review app instance will be spun down - saving us some money/free dyno hours. At this point you can head back to the heroku pipeline to view the deploy logs. Give it a couple of minutes to run and your app will be deployed! You can also check in on the deployment in the GitHub environment screen, by clicking the environments button on your repo's home page. Once the app has been deployed, this will change to read Deployed . Click the View deployment button...and it's broken! Why did production break when the review app works? koil comes with an app.json file that acts as a configuration for Heroku review apps. This file contains configuration for our postgres database so that Heroku knows to spin one up for each review app. Unfortunately, the app.json file doesn't have any impact on production, so we'll have to do the initial setup manually. This is a one-time thing. Automated provisioning of these resources is out of the scope of this tutorial, but you could checkout the Heroku docs on Terraform if it's something you're interested in. Step 6: Spinning up the production database Navigate over to the application in Heroku and go to the resources tab: And provision a free database: Now click More at the top right and Restart all dynos . Now - after the restart completes - we can try clicking Open App again... Success! Our app is now live in production! Step 7: Reflect on the result To conclude, we now have: an automated process that runs all of our tests for a pull request; on test success deploys the pull request code to a unique, isolated environment; on merge deletes the review application automatically; and deploys the change to production. This is incredibly powerful. Whether you're working solo or in a team, we think having a way to easily review and trial changes before letting a customer get access to them is the way forward. There's more yet to do though! Continue on below to allow your application to send email, report errors to sentry and to have a long-lived staging environment for QA. Connecting the CLI So far, everything we've done has made use of the Heroku website. Moving forward, we'll be provisioning extra add-ons using the CLI . This makes simple tasks much easier and gives us access to some more tooling - such as being able to stream logs with heroku logs --tail . Use the documentation to install and login to the CLI before going forward. Once you have the CLI installed, navigate to your project in the terminal and run heroku git:remote -a $MY_PROJECT_NAME where $MY_PROJECT_NAME is the name of your heroku app. You should see output like the image below: And you're set! Adding Mailgun Now we have a live application, we'd like to make use of the other features that koil gives us out of the box. First up: email. We're using Mailgun here, but since koil leverages spring-mail (which in turn just uses SMTP) you can feel free to substitute for your favourite SMTP email provider. Step 1: Adding Mailgun to your production application Navigate to your project on your machine and run the following command: heroku addons:create mailgun:starter You'll see output like the following: Looking at this output, we see that the Mailgun add-on has added a bunch of environment variables to our application. We'll need to update our app to reflect this... right? Step 2: Updating application to use env variables Wrong! Head over to src/main/resources/application.properties in your editor of choice. You'll see we have some properties that rely on the MAILGUN_ environment variables we've just configured: Great! This means that we don't have to do anything else to make this work. If there are MAILGUN_ env variables then we'll send email successfully. If these variables aren't passed at runtime, then koil will silently fall back on a LoggingMailSender that just logs each message. If you decided to use a different mail provider, you'll be able to modify these settings to respect whatever environment variables that add-on injects in this file. This is out of the scope of this tutorial. Adding JVM metrics Heroku offers language specific metrics for applications running on any paid dyno tier (so Hobby and up). This includes JVM specific metrics around things like garbage collection and heap usage. You can read more about the JVM specific metrics on offer here . Step 1: Adding the metrics to the app We'll be adding the JVM metrics integration to our production app. To enable these metrics, navigate to your app in the terminal and run heroku labs:enable \"runtime-heroku-metrics\" . This should result in output: Once that's done, you must re-deploy the dynos for the app. You can do this by running the heroku dyno:restart command in the terminal. This will result in output: It will take a few minutes for these metrics to show up so feel free to stop here for a cup of coffee. Step 2: Viewing the metrics Head back to your Heroku app in the browser and open the Metrics tab. On this page you'll see a bunch of metrics about your app in production. These include metrics around requests per second, request latency and more. If you scroll down then you should see the newly added JVM metrics: And that's it! It's due to this kind of simplicity that we love Heroku. Adding Sentry Production monitoring is a tricky thing to get right. A great starting point in our opinion is enabling Sentry to track errors both on the app server and in the user's browser. koil comes with Sentry pre-configured so it's as easy as turning it on! Step 1: Enable sentry in Heroku Heroku has a Sentry add-on that works with koil out of the box. To enable it, navigate to your project in the terminal and run: heroku addons:create sentry:f1 . You'll get output: Now let's restart our dyno using the heroku dyno:restart command. Go have a cold glass of water. This'll be done by the time you're back. Step 2: Viewing our new dashboard The Heroku CLI gives us a convenient way to access our Sentry instance. Run heroku addons:open sentry and be amazed as your browser opens and uses single-sign-on to log you in. There won't be any activity here yet. Let's head over to our application and throw an error. Step 3: Throwing an error koil integrates with Sentry at two points. It configures Sentry for Spring so that any unhandled exceptions on the server are recorded, and it adds a JS snippet to the rendered page in the browser so that we track any JS errors client-side. Let's leverage the latter to throw an error. Open the developer tools in your favourite browser and throw an error for Sentry: And see it appear in the Sentry dashboard: Ta-da! Step 4: (Optional) Integrate with Sentry release By integrating with the Sentry release functionality we can see useful information about which version of our application is throwing errors. Easy option We recommend using the Heroku Labs: Dyno Metadata functionality in Heroku to have the commit SHA env variable available at runtime. We run the command heroku labs:enable runtime-dyno-metadata , then redeploy the application by making a small change and pushing to GitHub or by using the Manual Deploy button in the application's deploy settings on Heroku itself. Once this is done, you can run the heroku config command to see the commit SHA being passed as an env variable: By default, koil allows source maps in production - see motivation here - which makes debugging errors in production a little easier. Despite this, we recommend hooking Sentry up to your GitHub repo so that it can show the source code for errors thrown. If you don't use GitHub then there are alternatives with documentation here . Harder option Sentry recommends using GitHub actions to set up Sentry with runtime information and releases. We haven't gotten around to doing this for koil yet, but you can follow their guidelines here . Adding LogDNA LogDNA is a log aggregation product that includes a bunch of nice features at a reasonable price. If you'd like to use something else, then feel free! koil logs to STDOUT in a JSON format in production, so you should be able to use almost any log aggregation product. We'll be using the Heroku add-on to deploy this . Step 1: Enabling the add-on First, let's run the Heroku CLI command heroku addons:create logdna:quaco to enable the free tier of LogDNA: Nothing more to see here really. Step 2: Opening logdna Let's use the Heroku CLI to open LogDNA. Run heroku addons:open logdna in the terminal in your application directory and you'll be taken to LogDNA: Huzzah! Here we can see everything that's logged by every running dyno for our production application. There are a bunch of features in LogDNA that are worth exploring. You can find out more in their documentation . Log aggregation doesn't depend on much in the way of application behaviour, so there's nothing specific to koil here really.","title":"Deploy to Heroku"},{"location":"deploy/heroku/#deploying-to-heroku","text":"Heroku is a PaaS product that makes deploying your application easy. With its generous free tier it's a perfect way to kick off a new project. It's easy to deploy a koil application with Heroku. We can also benefit tremendously from the Heroku add-on ecosystem: mailgun as an SMTP server to send emails; sentry for error-tracking; logdna for log aggregation; and hosted postgresql as a data store. You can check the other add-ons heroku comes with out of the box here .","title":"Deploying to Heroku"},{"location":"deploy/heroku/#minimum-viable-deployment","text":"There are a couple of ways that we can deploy to Heroku - they maintain excellent docs on this here . The deployment mechanism we'll be focusing on is the GitHub integration. We'll be building out a production-ready pipeline here. We'll connect our app to a koil based GitHub repo and deploy the application with a database. One of the primary benefits to working in koil is simplicity of building and deploying. It's a single, stateless JVM instance that's connected to a database. Most of the tricky first-time setup has already been done in the gradle build scripts. As such, anything that can deploy a Spring Boot project can deploy a koil project without difficulty. As it happens, Heroku has terrific integration with Spring Boot so deploying a live, production-ready application is pretty simple. I'm going to presume you've signed up to a Heroku account, if you haven't then do so , login to the Heroku dashboard and get ready to go.","title":"Minimum Viable Deployment"},{"location":"deploy/heroku/#step-1-create-a-heroku-app","text":"If you've just signed up to Heroku you'll be presented with an empty dashboard. On this page, click the New button and select App . This will take you to the create application page: When there, fill in the details for your application and hit Create App . This will take you on to your new app page: Hooray! An app is born!","title":"Step 1: Create a Heroku App"},{"location":"deploy/heroku/#step-2-create-a-pipeline-and-deploy","text":"Now, our app doesn't actually do anything yet. Let's fix that. You'll be prompted to add this app to a pipeline at the top of the page. Click to create a new pipeline and fill in the details: This will forward you on to the newly created pipeline: When here, click the prompt to Connect to Github . If you don't see this prompt, then navigate to the Settings tab. Once on this page, search for your GitHub repo then connect. While you're here, I'd really recommend enabling review apps . You can see the settings we recommend in the image below: They'll give you a great way to interact with pull request changes before merging. koil comes with an app.json file configured that specifies the required postgres database for your review apps. If you'd like to add other addons for each review app, then you can do so by modifying app.json . Heroku will respect the changes on the next deploy.","title":"Step 2: Create a pipeline and deploy"},{"location":"deploy/heroku/#step-3-enable-automatic-deploys","text":"Navigate back to the Pipeline tab to see the new setup. We'll add a staging environment here later. For now, let's enable automatic deploys. Click the menu toggle button on the production app. And click Configure automatic deploys... . You'll be presented with some options. We recommend deploying master only after CI passes. And we're set! This means that the next time we merge into master we'll see our application automatically updated!","title":"Step 3: Enable automatic deploys"},{"location":"deploy/heroku/#step-4-making-a-change","text":"Let's make a tiny change. I've added a new empty line between two tags in src/webapp/src/templates/pages/index.peb . You could do something more dramatic here of course. Commit this change on a feature branch feature/example and push to github. Now go to your repo in the browser and you'll be prompted to open a pull-request. Click the Compare & pull request... button, fill out the form on this page and then create the pull request. Alright! Now go make a cup of coffee while the CI build runs. koil has a longer build than a base Spring Boot project, but we promise it's worth it. Right now GitHub is running unit, integration and feature tests on the back-end and has kicked off Cypress to test your front-end. Once it's done, you should see something like this: Click the View deployment button and... Ta-da! Our review app is live! This has its own Heroku Postgres instance spun up, so we can play around with it without impacting a shared database. Note: we've still not finished the setup for our production app yet - read on to finish the required setup.","title":"Step 4: Making a change"},{"location":"deploy/heroku/#step-5-merging-to-master-and-deploying-to-production","text":"Now we've done some QA on our review app, we'll merge the pull request and deploy to production. Normally, this is where a teammate would review our change, but for now we can safely click the Merge button and carry on solo. Upon merging the pull request, the review app instance will be spun down - saving us some money/free dyno hours. At this point you can head back to the heroku pipeline to view the deploy logs. Give it a couple of minutes to run and your app will be deployed! You can also check in on the deployment in the GitHub environment screen, by clicking the environments button on your repo's home page. Once the app has been deployed, this will change to read Deployed . Click the View deployment button...and it's broken! Why did production break when the review app works? koil comes with an app.json file that acts as a configuration for Heroku review apps. This file contains configuration for our postgres database so that Heroku knows to spin one up for each review app. Unfortunately, the app.json file doesn't have any impact on production, so we'll have to do the initial setup manually. This is a one-time thing. Automated provisioning of these resources is out of the scope of this tutorial, but you could checkout the Heroku docs on Terraform if it's something you're interested in.","title":"Step 5: Merging to master and deploying to production"},{"location":"deploy/heroku/#step-6-spinning-up-the-production-database","text":"Navigate over to the application in Heroku and go to the resources tab: And provision a free database: Now click More at the top right and Restart all dynos . Now - after the restart completes - we can try clicking Open App again... Success! Our app is now live in production!","title":"Step 6: Spinning up the production database"},{"location":"deploy/heroku/#step-7-reflect-on-the-result","text":"To conclude, we now have: an automated process that runs all of our tests for a pull request; on test success deploys the pull request code to a unique, isolated environment; on merge deletes the review application automatically; and deploys the change to production. This is incredibly powerful. Whether you're working solo or in a team, we think having a way to easily review and trial changes before letting a customer get access to them is the way forward. There's more yet to do though! Continue on below to allow your application to send email, report errors to sentry and to have a long-lived staging environment for QA.","title":"Step 7: Reflect on the result"},{"location":"deploy/heroku/#connecting-the-cli","text":"So far, everything we've done has made use of the Heroku website. Moving forward, we'll be provisioning extra add-ons using the CLI . This makes simple tasks much easier and gives us access to some more tooling - such as being able to stream logs with heroku logs --tail . Use the documentation to install and login to the CLI before going forward. Once you have the CLI installed, navigate to your project in the terminal and run heroku git:remote -a $MY_PROJECT_NAME where $MY_PROJECT_NAME is the name of your heroku app. You should see output like the image below: And you're set!","title":"Connecting the CLI"},{"location":"deploy/heroku/#adding-mailgun","text":"Now we have a live application, we'd like to make use of the other features that koil gives us out of the box. First up: email. We're using Mailgun here, but since koil leverages spring-mail (which in turn just uses SMTP) you can feel free to substitute for your favourite SMTP email provider.","title":"Adding Mailgun"},{"location":"deploy/heroku/#step-1-adding-mailgun-to-your-production-application","text":"Navigate to your project on your machine and run the following command: heroku addons:create mailgun:starter You'll see output like the following: Looking at this output, we see that the Mailgun add-on has added a bunch of environment variables to our application. We'll need to update our app to reflect this... right?","title":"Step 1: Adding Mailgun to your production application"},{"location":"deploy/heroku/#step-2-updating-application-to-use-env-variables","text":"Wrong! Head over to src/main/resources/application.properties in your editor of choice. You'll see we have some properties that rely on the MAILGUN_ environment variables we've just configured: Great! This means that we don't have to do anything else to make this work. If there are MAILGUN_ env variables then we'll send email successfully. If these variables aren't passed at runtime, then koil will silently fall back on a LoggingMailSender that just logs each message. If you decided to use a different mail provider, you'll be able to modify these settings to respect whatever environment variables that add-on injects in this file. This is out of the scope of this tutorial.","title":"Step 2: Updating application to use env variables"},{"location":"deploy/heroku/#adding-jvm-metrics","text":"Heroku offers language specific metrics for applications running on any paid dyno tier (so Hobby and up). This includes JVM specific metrics around things like garbage collection and heap usage. You can read more about the JVM specific metrics on offer here .","title":"Adding JVM metrics"},{"location":"deploy/heroku/#step-1-adding-the-metrics-to-the-app","text":"We'll be adding the JVM metrics integration to our production app. To enable these metrics, navigate to your app in the terminal and run heroku labs:enable \"runtime-heroku-metrics\" . This should result in output: Once that's done, you must re-deploy the dynos for the app. You can do this by running the heroku dyno:restart command in the terminal. This will result in output: It will take a few minutes for these metrics to show up so feel free to stop here for a cup of coffee.","title":"Step 1: Adding the metrics to the app"},{"location":"deploy/heroku/#step-2-viewing-the-metrics","text":"Head back to your Heroku app in the browser and open the Metrics tab. On this page you'll see a bunch of metrics about your app in production. These include metrics around requests per second, request latency and more. If you scroll down then you should see the newly added JVM metrics: And that's it! It's due to this kind of simplicity that we love Heroku.","title":"Step 2: Viewing the metrics"},{"location":"deploy/heroku/#adding-sentry","text":"Production monitoring is a tricky thing to get right. A great starting point in our opinion is enabling Sentry to track errors both on the app server and in the user's browser. koil comes with Sentry pre-configured so it's as easy as turning it on!","title":"Adding Sentry"},{"location":"deploy/heroku/#step-1-enable-sentry-in-heroku","text":"Heroku has a Sentry add-on that works with koil out of the box. To enable it, navigate to your project in the terminal and run: heroku addons:create sentry:f1 . You'll get output: Now let's restart our dyno using the heroku dyno:restart command. Go have a cold glass of water. This'll be done by the time you're back.","title":"Step 1: Enable sentry in Heroku"},{"location":"deploy/heroku/#step-2-viewing-our-new-dashboard","text":"The Heroku CLI gives us a convenient way to access our Sentry instance. Run heroku addons:open sentry and be amazed as your browser opens and uses single-sign-on to log you in. There won't be any activity here yet. Let's head over to our application and throw an error.","title":"Step 2: Viewing our new dashboard"},{"location":"deploy/heroku/#step-3-throwing-an-error","text":"koil integrates with Sentry at two points. It configures Sentry for Spring so that any unhandled exceptions on the server are recorded, and it adds a JS snippet to the rendered page in the browser so that we track any JS errors client-side. Let's leverage the latter to throw an error. Open the developer tools in your favourite browser and throw an error for Sentry: And see it appear in the Sentry dashboard: Ta-da!","title":"Step 3: Throwing an error"},{"location":"deploy/heroku/#step-4-optional-integrate-with-sentry-release","text":"By integrating with the Sentry release functionality we can see useful information about which version of our application is throwing errors.","title":"Step 4: (Optional) Integrate with Sentry release"},{"location":"deploy/heroku/#easy-option","text":"We recommend using the Heroku Labs: Dyno Metadata functionality in Heroku to have the commit SHA env variable available at runtime. We run the command heroku labs:enable runtime-dyno-metadata , then redeploy the application by making a small change and pushing to GitHub or by using the Manual Deploy button in the application's deploy settings on Heroku itself. Once this is done, you can run the heroku config command to see the commit SHA being passed as an env variable: By default, koil allows source maps in production - see motivation here - which makes debugging errors in production a little easier. Despite this, we recommend hooking Sentry up to your GitHub repo so that it can show the source code for errors thrown. If you don't use GitHub then there are alternatives with documentation here .","title":"Easy option"},{"location":"deploy/heroku/#harder-option","text":"Sentry recommends using GitHub actions to set up Sentry with runtime information and releases. We haven't gotten around to doing this for koil yet, but you can follow their guidelines here .","title":"Harder option"},{"location":"deploy/heroku/#adding-logdna","text":"LogDNA is a log aggregation product that includes a bunch of nice features at a reasonable price. If you'd like to use something else, then feel free! koil logs to STDOUT in a JSON format in production, so you should be able to use almost any log aggregation product. We'll be using the Heroku add-on to deploy this .","title":"Adding LogDNA"},{"location":"deploy/heroku/#step-1-enabling-the-add-on","text":"First, let's run the Heroku CLI command heroku addons:create logdna:quaco to enable the free tier of LogDNA: Nothing more to see here really.","title":"Step 1: Enabling the add-on"},{"location":"deploy/heroku/#step-2-opening-logdna","text":"Let's use the Heroku CLI to open LogDNA. Run heroku addons:open logdna in the terminal in your application directory and you'll be taken to LogDNA: Huzzah! Here we can see everything that's logged by every running dyno for our production application. There are a bunch of features in LogDNA that are worth exploring. You can find out more in their documentation . Log aggregation doesn't depend on much in the way of application behaviour, so there's nothing specific to koil here really.","title":"Step 2: Opening logdna"},{"location":"tutorials/cypress/","text":"Testing our front-end with Cypress \"No one shall expel us from the Paradise that Cypress has created.\" -- Me, right now We love Cypress , and after this tutorial we're sure you will too. If you've never encountered Cypress before, it allows us to write fast, functional, front-end tests that run in an actual browser using standard js tooling. It has a very gentle learning curve if you're already comfortable writing front-end code, and a moderate one if you are not. If you've never used Cypress before, then we recommend reading through their docs as well as this. While we'll cover some basics in this tutorial, we'll really just be skimming the surface to show how Cypress fits in to koil. Creating and running a Cypress test Step 0: Installing Node.js If you already have Node 12, then feel free to skip this. Cypress needs Node.js to run. Normally, when you build a koil project, gradle will pull down the required node version and use it to build your front-end assets. To install Node.js on your machine for use globally, we recommend using the Node Version Manager to install the latest LTS version of node ( nvm install --lts ). Once that's done, navigate to the src/webapp directory in your koil project and run npm ci : This installs the dependencies you need at the same version that we used when creating koil. While npm install will work, it will also update a bunch of dependencies. In a perfect world, no breaking change would find its way into a minor version update. Alas, we don't live in a perfect world, and so we've found it better to use npm ci unless we're explicitly trying to update. This might be a little slow the first time (you'll also be pulling down the Cypress binaries) it runs, so feel free to stop here to have some punch and pie. Introducing the Cypress test runner First up, we'll presume you have a koil project ready to go and that you've got a working node environment. In the src/webapp directory, run the npx cypress open command, and you'll be greeted with the Cypress runner: We can see that we have a couple of test specs already here. If you click the button labelled Run all specs at the top right a new window will open, and you'll see some automated UI tests run: These are some basic tests we've included to verify registration and login flows. This runner window is where we'll be spending most of our time as we write our tests. If we open src/webapp/cypress/integration/login.js we'll see some of the test cases that just ran: There are a couple of things to pay attention to here: we're using the Mocha test framework which Cypress comes with out of the box; we're looping over an array of device names to generate tests for different device sizes; we're using a custom command to create a new account in the before each (which you can find in `src/webapp/cypress/support/commands.js); and our tests are written in plain ol' javascript. You'll be using these techniques going forward to write a specification testing the mobile menu button on the index page. Creating our test spec In the src/webapp/cypress/integration directory, create a new file called mobile_navigation.js . In your favourite editor, add some boilerplate code: describe ( `User can open mobile menu` , () => { beforeEach (() => { cy . visit ( '/' ) }) it ( `should show mobile menu on button click` , () => { cy . pause () }); }); Now, let's go back to the Cypress Runner. You should see a new spec file is listed: Click on the file name mobile_navigation.js and you'll be taken to the running tests: Alright! This test is on the index page and is currently paused. This is because of the cy.pause() statement in our test case body (line 7 if you copy-pasted). You can click the play button at the top of the left-pane to resume. Adding some pause lines into tests when debugging is a great way to step through in increments. More meaningful test case Our test above doesn't really do anything, so let's fix that. First, consider that we're trying to test a bit of functionality on mobile, but the test is running on what looks like a laptop screen size. In the beforeEach of the spec file add a line to change viewport: beforeEach (() => { cy . visit ( '/' ) cy . viewport ( 'iphone-6' ) }) Now when we run our test we'll see that Cypress is running on a screen with the same resolution as an iPhone 6: Pretty easy! The next thing we'd like to do is to assert that the menu isn't visible when we first arrive on the page. There are a bunch of ways to refer to an element in Cypress (by using normal CSS selectors), but we strongly recommend using data-test attributes as advised here . Head on over to the index page template at src/webapp/src/templates/pages/index.peb . You'll see on line 21 that we already have a data-test attribute: < div class = \"navbar-menu is-hidden-tablet\" data-target = \"menu.toggleable\" data-test = \"mobile-menu\" > < div class = \"menu\" > < ul class = \"menu-list\" > < li >< a href = \"/auth/login\" > Login </ a ></ li > < li >< a href = \"/auth/register\" > Sign Up </ a ></ li > </ ul > </ div > </ div > That is, data-test=\"mobile-menu\" . To assert that it's not visible, let's add a line to our test case: it ( `should show mobile menu on button click` , () => { cy . get ( '[data-test=mobile-menu]' ). should ( 'not.be.visible' ) cy . pause () }); When you save this file, the open runner will re-run the test automatically. You'll see in the left pane that an assertion ran before pausing this time: Neat! Now let's add in a couple more actions for our test to take. We want to click the menu button and assert that a menu is now visible. If you return to src/webapp/src/templates/pages/index.peb , you'll see that our menu button already has a test attribute data-test=\"menu-button\" . Using this in our test, we get: it ( `should show mobile menu on button click` , () => { cy . get ( '[data-test=mobile-menu]' ). should ( 'not.exist' ) cy . get ( '[data-test=menu-button' ). click () cy . get ( '[data-test=mobile-menu]' ). should ( 'be.visible' ) }); To clarify what's going on here: we're getting the menu-button element and clicking it. Then we're selecting the mobile-menu again and verifying that it's visible. To give this a BDD slant, the test would read GIVEN the mobile menu isn't visible WHEN the menu button is clicked THEN the mobile menu is visible . And we're done! We can now say with confidence that the menu works on mobile. Running on more devices A favourite trick of ours is to run a cypress test for a variety of different viewport sizes. This saves a bunch of time in verifying that our website works across screen sizes without manual QA. Add a device array to the top of the file: const sizes = [ 'iphone-6' , 'iphone-x' , 'ipad-mini' ]; We'll loop over this array, and add the existing test contents to the inner loop: const sizes = [ 'iphone-6' , 'iphone-x' , 'ipad-mini' ]; sizes . forEach ( size => { describe ( `User can open mobile menu on ${ size } ` , () => { beforeEach (() => { cy . visit ( '/' ) cy . viewport ( size ) }) it ( `should show mobile menu on button click` , () => { cy . get ( '[data-test=mobile-menu]' ). should ( 'not.be.visible' ) cy . get ( '[data-test=menu-button' ). click () cy . get ( '[data-test=mobile-menu]' ). should ( 'be.visible' ) }); }); }) Note we've made two other changes here: we've added the size parameter to the describe string of our spec; and we've modified our beforeEach to call cy.viewport(size) . This results in: Sweet! Note that the test names now include the device preset name. To see more viewport aliases you can add, checkout this page . Testing functionality that requires authentication Frequently, we need to create a test account, log in as that user, and interact with some functionality only available to authenticated users. To help with this, we've created a custom cypress command cy.createRandomAccountAndLogin() . As an example of it in use, we''ll be adding another test case to the mobile_navigation.js file: it ( `should show mobile menu on dashboard` , () => { cy . createRandomAccountAndLogin (); cy . get ( '[data-test=mobile-menu]' ). should ( 'not.exist' ) cy . get ( '[data-test=menu-button' ). click () cy . get ( '[data-test=mobile-menu]' ). should ( 'be.visible' ) }); The navbar used on these pages has been given the same attributes that we used before: data-test=\"mobile-menu\" and data-test=\"menu-button\" . If you step through this test, you'll see that it makes some POST requests to create the account then navigates to /dashboard . This is much preferred to working through these flows as a user would. We have tests that explicitly verify the authentication already, so any benefit to going through that process every time would be marginal. On the other hand, we'd be paying the cost with slower tests down and tighter coupling between the UI authentication flows and tests that don't really care what the auth UI looks like. Running the test suite in JUnit While the Cypress test runner is a great tool, we don't really want to have to open it every time we make a change. Instead, we probably just want these tests to run as a part of our normal test suite. Inspired by this blog post , we've written a JUnit test class that will run our entire suite. Note: the author of the blog post above has also released a library to do a lot of the work for us. We're working on integrating this with koil soon. You can find this test at src/test/kotlin/org/koil/CypressIntegrationTest.kt This test will also be run as a part of a gradle build , making our CI runs super easy. Caveat A fairly natural next step here might be to write test setup code (e.g. create used account) in the JUnit test. We don't recommend this. Not only does it make running the test without JUnit very difficult, it also couples us quite tightly to this implementation as a Spring-based monolith. One of the primary benefits to Cypress testing in the way we advocate is that our tests are very loosely-coupled to the implementation of our application. We'd be loathe to lose that. Conclusion Well there we have it. A browser-based front-end test that runs automatically as a part of our build. As mentioned at the beginning, if you've not used Cypress before then we highly recommend digging in on their website . We think you'll be impressed.","title":"Testing the front-end with Cypress"},{"location":"tutorials/cypress/#testing-our-front-end-with-cypress","text":"\"No one shall expel us from the Paradise that Cypress has created.\" -- Me, right now We love Cypress , and after this tutorial we're sure you will too. If you've never encountered Cypress before, it allows us to write fast, functional, front-end tests that run in an actual browser using standard js tooling. It has a very gentle learning curve if you're already comfortable writing front-end code, and a moderate one if you are not. If you've never used Cypress before, then we recommend reading through their docs as well as this. While we'll cover some basics in this tutorial, we'll really just be skimming the surface to show how Cypress fits in to koil.","title":"Testing our front-end with Cypress"},{"location":"tutorials/cypress/#creating-and-running-a-cypress-test","text":"","title":"Creating and running a Cypress test"},{"location":"tutorials/cypress/#step-0-installing-nodejs","text":"If you already have Node 12, then feel free to skip this. Cypress needs Node.js to run. Normally, when you build a koil project, gradle will pull down the required node version and use it to build your front-end assets. To install Node.js on your machine for use globally, we recommend using the Node Version Manager to install the latest LTS version of node ( nvm install --lts ). Once that's done, navigate to the src/webapp directory in your koil project and run npm ci : This installs the dependencies you need at the same version that we used when creating koil. While npm install will work, it will also update a bunch of dependencies. In a perfect world, no breaking change would find its way into a minor version update. Alas, we don't live in a perfect world, and so we've found it better to use npm ci unless we're explicitly trying to update. This might be a little slow the first time (you'll also be pulling down the Cypress binaries) it runs, so feel free to stop here to have some punch and pie.","title":"Step 0: Installing Node.js"},{"location":"tutorials/cypress/#introducing-the-cypress-test-runner","text":"First up, we'll presume you have a koil project ready to go and that you've got a working node environment. In the src/webapp directory, run the npx cypress open command, and you'll be greeted with the Cypress runner: We can see that we have a couple of test specs already here. If you click the button labelled Run all specs at the top right a new window will open, and you'll see some automated UI tests run: These are some basic tests we've included to verify registration and login flows. This runner window is where we'll be spending most of our time as we write our tests. If we open src/webapp/cypress/integration/login.js we'll see some of the test cases that just ran: There are a couple of things to pay attention to here: we're using the Mocha test framework which Cypress comes with out of the box; we're looping over an array of device names to generate tests for different device sizes; we're using a custom command to create a new account in the before each (which you can find in `src/webapp/cypress/support/commands.js); and our tests are written in plain ol' javascript. You'll be using these techniques going forward to write a specification testing the mobile menu button on the index page.","title":"Introducing the Cypress test runner"},{"location":"tutorials/cypress/#creating-our-test-spec","text":"In the src/webapp/cypress/integration directory, create a new file called mobile_navigation.js . In your favourite editor, add some boilerplate code: describe ( `User can open mobile menu` , () => { beforeEach (() => { cy . visit ( '/' ) }) it ( `should show mobile menu on button click` , () => { cy . pause () }); }); Now, let's go back to the Cypress Runner. You should see a new spec file is listed: Click on the file name mobile_navigation.js and you'll be taken to the running tests: Alright! This test is on the index page and is currently paused. This is because of the cy.pause() statement in our test case body (line 7 if you copy-pasted). You can click the play button at the top of the left-pane to resume. Adding some pause lines into tests when debugging is a great way to step through in increments.","title":"Creating our test spec"},{"location":"tutorials/cypress/#more-meaningful-test-case","text":"Our test above doesn't really do anything, so let's fix that. First, consider that we're trying to test a bit of functionality on mobile, but the test is running on what looks like a laptop screen size. In the beforeEach of the spec file add a line to change viewport: beforeEach (() => { cy . visit ( '/' ) cy . viewport ( 'iphone-6' ) }) Now when we run our test we'll see that Cypress is running on a screen with the same resolution as an iPhone 6: Pretty easy! The next thing we'd like to do is to assert that the menu isn't visible when we first arrive on the page. There are a bunch of ways to refer to an element in Cypress (by using normal CSS selectors), but we strongly recommend using data-test attributes as advised here . Head on over to the index page template at src/webapp/src/templates/pages/index.peb . You'll see on line 21 that we already have a data-test attribute: < div class = \"navbar-menu is-hidden-tablet\" data-target = \"menu.toggleable\" data-test = \"mobile-menu\" > < div class = \"menu\" > < ul class = \"menu-list\" > < li >< a href = \"/auth/login\" > Login </ a ></ li > < li >< a href = \"/auth/register\" > Sign Up </ a ></ li > </ ul > </ div > </ div > That is, data-test=\"mobile-menu\" . To assert that it's not visible, let's add a line to our test case: it ( `should show mobile menu on button click` , () => { cy . get ( '[data-test=mobile-menu]' ). should ( 'not.be.visible' ) cy . pause () }); When you save this file, the open runner will re-run the test automatically. You'll see in the left pane that an assertion ran before pausing this time: Neat! Now let's add in a couple more actions for our test to take. We want to click the menu button and assert that a menu is now visible. If you return to src/webapp/src/templates/pages/index.peb , you'll see that our menu button already has a test attribute data-test=\"menu-button\" . Using this in our test, we get: it ( `should show mobile menu on button click` , () => { cy . get ( '[data-test=mobile-menu]' ). should ( 'not.exist' ) cy . get ( '[data-test=menu-button' ). click () cy . get ( '[data-test=mobile-menu]' ). should ( 'be.visible' ) }); To clarify what's going on here: we're getting the menu-button element and clicking it. Then we're selecting the mobile-menu again and verifying that it's visible. To give this a BDD slant, the test would read GIVEN the mobile menu isn't visible WHEN the menu button is clicked THEN the mobile menu is visible . And we're done! We can now say with confidence that the menu works on mobile.","title":"More meaningful test case"},{"location":"tutorials/cypress/#running-on-more-devices","text":"A favourite trick of ours is to run a cypress test for a variety of different viewport sizes. This saves a bunch of time in verifying that our website works across screen sizes without manual QA. Add a device array to the top of the file: const sizes = [ 'iphone-6' , 'iphone-x' , 'ipad-mini' ]; We'll loop over this array, and add the existing test contents to the inner loop: const sizes = [ 'iphone-6' , 'iphone-x' , 'ipad-mini' ]; sizes . forEach ( size => { describe ( `User can open mobile menu on ${ size } ` , () => { beforeEach (() => { cy . visit ( '/' ) cy . viewport ( size ) }) it ( `should show mobile menu on button click` , () => { cy . get ( '[data-test=mobile-menu]' ). should ( 'not.be.visible' ) cy . get ( '[data-test=menu-button' ). click () cy . get ( '[data-test=mobile-menu]' ). should ( 'be.visible' ) }); }); }) Note we've made two other changes here: we've added the size parameter to the describe string of our spec; and we've modified our beforeEach to call cy.viewport(size) . This results in: Sweet! Note that the test names now include the device preset name. To see more viewport aliases you can add, checkout this page .","title":"Running on more devices"},{"location":"tutorials/cypress/#testing-functionality-that-requires-authentication","text":"Frequently, we need to create a test account, log in as that user, and interact with some functionality only available to authenticated users. To help with this, we've created a custom cypress command cy.createRandomAccountAndLogin() . As an example of it in use, we''ll be adding another test case to the mobile_navigation.js file: it ( `should show mobile menu on dashboard` , () => { cy . createRandomAccountAndLogin (); cy . get ( '[data-test=mobile-menu]' ). should ( 'not.exist' ) cy . get ( '[data-test=menu-button' ). click () cy . get ( '[data-test=mobile-menu]' ). should ( 'be.visible' ) }); The navbar used on these pages has been given the same attributes that we used before: data-test=\"mobile-menu\" and data-test=\"menu-button\" . If you step through this test, you'll see that it makes some POST requests to create the account then navigates to /dashboard . This is much preferred to working through these flows as a user would. We have tests that explicitly verify the authentication already, so any benefit to going through that process every time would be marginal. On the other hand, we'd be paying the cost with slower tests down and tighter coupling between the UI authentication flows and tests that don't really care what the auth UI looks like.","title":"Testing functionality that requires authentication"},{"location":"tutorials/cypress/#running-the-test-suite-in-junit","text":"While the Cypress test runner is a great tool, we don't really want to have to open it every time we make a change. Instead, we probably just want these tests to run as a part of our normal test suite. Inspired by this blog post , we've written a JUnit test class that will run our entire suite. Note: the author of the blog post above has also released a library to do a lot of the work for us. We're working on integrating this with koil soon. You can find this test at src/test/kotlin/org/koil/CypressIntegrationTest.kt This test will also be run as a part of a gradle build , making our CI runs super easy.","title":"Running the test suite in JUnit"},{"location":"tutorials/cypress/#caveat","text":"A fairly natural next step here might be to write test setup code (e.g. create used account) in the JUnit test. We don't recommend this. Not only does it make running the test without JUnit very difficult, it also couples us quite tightly to this implementation as a Spring-based monolith. One of the primary benefits to Cypress testing in the way we advocate is that our tests are very loosely-coupled to the implementation of our application. We'd be loathe to lose that.","title":"Caveat"},{"location":"tutorials/cypress/#conclusion","text":"Well there we have it. A browser-based front-end test that runs automatically as a part of our build. As mentioned at the beginning, if you've not used Cypress before then we highly recommend digging in on their website . We think you'll be impressed.","title":"Conclusion"},{"location":"tutorials/gettingstarted/","text":"Getting Started with koil This is a guide to actually starting your first project with koil- step by step instructions from pulling the project down, getting it running for the first time and a few ways to start customizing it to be your own project. We use IntelliJ as our IDE so the instructions given below assume you have IntelliJ as well. If you want a tutorial using another IDE, let us know and we can add it! This tutorial intentionally goes step-by-step through common errors or mistakes someone might make while trying to get the project running. If you are an experienced developer- some of it might seem obvious and unnecessary to you. Pulling the Project form GitHub This might be an obvious one- but use the git clone command to pull down the koil Project. git clone git@github.com:HappyValleyIO/koil.git rvroger Getting it to Run (Short Version) This is the quick version to get koil to run successfully for the first time. If you want a bit more of an explanation of possible errors or why you are making changes - checkout the long version here Run the docker-compose up -d command in the folder that you've cloned the project into Open the project in Intellij. Wait for it to import the Gradle project. (2 minutes on a beefy computer) Run the SpringbootApplication Edit the Run Configuration while it builds the project (the initial build took just under 3 minutes on a beefy computer). You need to add the environment variable for running in Spring DEV (SPRING_PROFILES_ACTIVE=dev) to the configuration. Once the build finishes, the initial SpringBootApplication run will have failed. Now re-run it with your newly saved environment variables You should now be able to go to localhost:8080 and see the project running successfully. Getting it to Run (Long Version) Now we have pulled down the koil project, let's open it in your favorite IDE. I'm going to be using IntelliJ. Open IntelliJ File -> Open -> rvroger This is going to import the \"rvroger\" Gradle project. It can take a few minutes to pull in all the dependencies. It's tempting to click \"Background\" on the task and start changing things, but go make a cup of tea or coffee and just let it finish. (It took 2 minutes and 19 seconds for my computer to finish getting everything setup) Now let's run the application and see what we have. If you open \"src/main/kotlin/org.koil\" and right click koilApplication.kt, the \"Run\" option should be available in the menu (or if you are a shortcut wizard - \"CTRL + SHIFT + F10\"). Since this is the first time you will have built the project, it is going to take a bit of time to run. The \"buildAssets\" step in particular will take up the majority of this time. Mine took another 2 minutes and 46 seconds to finish the build. Now IntelliJ has finished the build- it's going to start running our application! Anddd we get a horrible error blowup: If we drill down and read the stack trace- we see the root cause here: Driver org.postgresql.Driver claims to not accept jdbcUrl, jdbc:postgresql:// ${ DB_SERVER } : ${ DB_PORT } / ${ DB_NAME } Take a look at our main resources- we have application.properties and application-dev.properties. By default, Spring is going to pick up application.properties, which, if we open it, expects to find environment variables for the database configuration. We are just trying to run a development instance here- so looking at application-dev.properties, it's already configured some test database properties. Since the DEV application properties file contains everything we need to run a local development instance of our application, we need to make sure that this is the file being picked up when we run. Let's edit the Run Configuration for koilApplication so that it uses the DEV spring profile. Since we tried to run this already- IntelliJ has a Run Configuration setup for us if we \"Edit Configurations\" from the run configuration menu. We need to add an environment variable: SPRING_PROFILES_ACTIVE=dev Save and let's try running with the new configuration changes. Again! Horrible errors: Looking at the error messages, the root error here is: Unable to obtain connection from database: FATAL: password authentication failed for user \"root\" We forgot to start the database- so it's unable to connect when trying to login. The database runs in a docker-container that we can start up using docker-compose. Using the terminal, go to the main project directory (rvroger in my case) then run the following command to bring up the database: Now we have the database up and running, let's finally start our application. Going back to Intellij, we re-run our koilApplication with the edited configuration to pickup the dev credentials - and now we have the actual application started successfully. Now open \"http://localhost:8080\" in your browser and you can see we have the koil starter running! We can even create a new account and login. That's it! You have a basic application with a website homepage, account registration and a basic dashboard upon logging in. Now we have the project running, let's customize the project a bit, so it isn't just a basic koil Template. Customize the Project - Database Name I started my career as a database developer - so I'm going to start with the dev database setup. Let's rename it from \"koil\" to our project name (rvroger in my case) Open docker-compose.yml and on line 11 the database name is specified. I'm going to replace the db name from \"koil\" to \"rvroger\" and then we will need to restart our database. In the main project directory in the terminal- bring down the current docker stack: docker-compose down Then bring it back up with docker-compose up -d Now, we have to tell the application dev setup to use the new database name. This is done by editing the application-dev.properties file. The datasource url needs to be updated to use the new database name. Now we can rebuild the project, either with the IntelliJ run buttons or \"CTRL+F9\" and we are back up and running, with a newly named Dev database. Customize the Project - Change the Applications Primary Color This is a bit of a silly change- but it's important to make your application feel like it is yours. So we are going to change the primary color used by all the UI for the project. The variables used by all the SCSS in this project are within the \"src/webapp/src/styles/components\" directory in the \"variables.scss\" file. If you open the variables.scss file, we can see that there are a number of color variables listed. We are just going to change one right now- the $primary variable. This variable controls the color of all attributes on the project marked as \"primary\". With the basic existing koil project, this is mainly going to affect things like button colors and backgrounds. Before we make this change- make sure you have an instance of koilApplication up and running. We want to see this change happen live. Initially- your website is going to look like this: I've created a new variable for this project called \"rvroger-blue\". This gives me the option of referencing this color for things other than primary classes in the future. Then I set the $primary variable to my new $rvroger-blue variable. Hit 'CTRL + F9' to rebuild the project - and watch the browser change from the koil maroon/red to our new primary blue color. That's just a starting point- but it lets you see how easily you can start to customize koil to get your application moving quickly. Changing something as simple as the primary project color starts to make the project feel like your application, not just a template. Next Steps Now that you've got things going, why not learn how to write a cypress test or how to deploy to production with heroku ?","title":"Getting Started with koil"},{"location":"tutorials/gettingstarted/#getting-started-with-koil","text":"This is a guide to actually starting your first project with koil- step by step instructions from pulling the project down, getting it running for the first time and a few ways to start customizing it to be your own project. We use IntelliJ as our IDE so the instructions given below assume you have IntelliJ as well. If you want a tutorial using another IDE, let us know and we can add it! This tutorial intentionally goes step-by-step through common errors or mistakes someone might make while trying to get the project running. If you are an experienced developer- some of it might seem obvious and unnecessary to you.","title":"Getting Started with koil"},{"location":"tutorials/gettingstarted/#pulling-the-project-form-github","text":"This might be an obvious one- but use the git clone command to pull down the koil Project. git clone git@github.com:HappyValleyIO/koil.git rvroger","title":"Pulling the Project form GitHub"},{"location":"tutorials/gettingstarted/#getting-it-to-run-short-version","text":"This is the quick version to get koil to run successfully for the first time. If you want a bit more of an explanation of possible errors or why you are making changes - checkout the long version here Run the docker-compose up -d command in the folder that you've cloned the project into Open the project in Intellij. Wait for it to import the Gradle project. (2 minutes on a beefy computer) Run the SpringbootApplication Edit the Run Configuration while it builds the project (the initial build took just under 3 minutes on a beefy computer). You need to add the environment variable for running in Spring DEV (SPRING_PROFILES_ACTIVE=dev) to the configuration. Once the build finishes, the initial SpringBootApplication run will have failed. Now re-run it with your newly saved environment variables You should now be able to go to localhost:8080 and see the project running successfully.","title":"Getting it to Run (Short Version)"},{"location":"tutorials/gettingstarted/#getting-it-to-run-long-version","text":"Now we have pulled down the koil project, let's open it in your favorite IDE. I'm going to be using IntelliJ. Open IntelliJ File -> Open -> rvroger This is going to import the \"rvroger\" Gradle project. It can take a few minutes to pull in all the dependencies. It's tempting to click \"Background\" on the task and start changing things, but go make a cup of tea or coffee and just let it finish. (It took 2 minutes and 19 seconds for my computer to finish getting everything setup) Now let's run the application and see what we have. If you open \"src/main/kotlin/org.koil\" and right click koilApplication.kt, the \"Run\" option should be available in the menu (or if you are a shortcut wizard - \"CTRL + SHIFT + F10\"). Since this is the first time you will have built the project, it is going to take a bit of time to run. The \"buildAssets\" step in particular will take up the majority of this time. Mine took another 2 minutes and 46 seconds to finish the build. Now IntelliJ has finished the build- it's going to start running our application! Anddd we get a horrible error blowup: If we drill down and read the stack trace- we see the root cause here: Driver org.postgresql.Driver claims to not accept jdbcUrl, jdbc:postgresql:// ${ DB_SERVER } : ${ DB_PORT } / ${ DB_NAME } Take a look at our main resources- we have application.properties and application-dev.properties. By default, Spring is going to pick up application.properties, which, if we open it, expects to find environment variables for the database configuration. We are just trying to run a development instance here- so looking at application-dev.properties, it's already configured some test database properties. Since the DEV application properties file contains everything we need to run a local development instance of our application, we need to make sure that this is the file being picked up when we run. Let's edit the Run Configuration for koilApplication so that it uses the DEV spring profile. Since we tried to run this already- IntelliJ has a Run Configuration setup for us if we \"Edit Configurations\" from the run configuration menu. We need to add an environment variable: SPRING_PROFILES_ACTIVE=dev Save and let's try running with the new configuration changes. Again! Horrible errors: Looking at the error messages, the root error here is: Unable to obtain connection from database: FATAL: password authentication failed for user \"root\" We forgot to start the database- so it's unable to connect when trying to login. The database runs in a docker-container that we can start up using docker-compose. Using the terminal, go to the main project directory (rvroger in my case) then run the following command to bring up the database: Now we have the database up and running, let's finally start our application. Going back to Intellij, we re-run our koilApplication with the edited configuration to pickup the dev credentials - and now we have the actual application started successfully. Now open \"http://localhost:8080\" in your browser and you can see we have the koil starter running! We can even create a new account and login. That's it! You have a basic application with a website homepage, account registration and a basic dashboard upon logging in. Now we have the project running, let's customize the project a bit, so it isn't just a basic koil Template.","title":"Getting it to Run (Long Version)"},{"location":"tutorials/gettingstarted/#customize-the-project-database-name","text":"I started my career as a database developer - so I'm going to start with the dev database setup. Let's rename it from \"koil\" to our project name (rvroger in my case) Open docker-compose.yml and on line 11 the database name is specified. I'm going to replace the db name from \"koil\" to \"rvroger\" and then we will need to restart our database. In the main project directory in the terminal- bring down the current docker stack: docker-compose down Then bring it back up with docker-compose up -d Now, we have to tell the application dev setup to use the new database name. This is done by editing the application-dev.properties file. The datasource url needs to be updated to use the new database name. Now we can rebuild the project, either with the IntelliJ run buttons or \"CTRL+F9\" and we are back up and running, with a newly named Dev database.","title":"Customize the Project - Database Name"},{"location":"tutorials/gettingstarted/#customize-the-project-change-the-applications-primary-color","text":"This is a bit of a silly change- but it's important to make your application feel like it is yours. So we are going to change the primary color used by all the UI for the project. The variables used by all the SCSS in this project are within the \"src/webapp/src/styles/components\" directory in the \"variables.scss\" file. If you open the variables.scss file, we can see that there are a number of color variables listed. We are just going to change one right now- the $primary variable. This variable controls the color of all attributes on the project marked as \"primary\". With the basic existing koil project, this is mainly going to affect things like button colors and backgrounds. Before we make this change- make sure you have an instance of koilApplication up and running. We want to see this change happen live. Initially- your website is going to look like this: I've created a new variable for this project called \"rvroger-blue\". This gives me the option of referencing this color for things other than primary classes in the future. Then I set the $primary variable to my new $rvroger-blue variable. Hit 'CTRL + F9' to rebuild the project - and watch the browser change from the koil maroon/red to our new primary blue color. That's just a starting point- but it lets you see how easily you can start to customize koil to get your application moving quickly. Changing something as simple as the primary project color starts to make the project feel like your application, not just a template.","title":"Customize the Project - Change the Applications Primary Color"},{"location":"tutorials/gettingstarted/#next-steps","text":"Now that you've got things going, why not learn how to write a cypress test or how to deploy to production with heroku ?","title":"Next Steps"},{"location":"tutorials/static/","text":"Adding a static-ish page koil has a pretty funky setup. We're using node to build web things that are then rendered/served with Spring Boot. As a result there are two ways to think about adding a static - or mostly static - page. We can either: * add a document as a fully static document in HTML; or * we can add a template that doesn't rely on a model and render it using Spring. While the former is a little easier, I'd recommend always going for the latter. It lets you use the same template engine, which means you get to leverage the same layout as the rest of your site. It also allows you to leverage the live reload functionality when working in the dev profile. Adding a new template to the project Project structure Almost all front-end assets are held in the src/webapp directory. If you dig into that directory you'll see a setup like so: So underneath the src/webapp directory we have a pretty standard NodeJs project layout. The src directory inside this project is what we're interested in right now. Let's run through what these directories represent: scripts: the javascript and typescript we're using in our project; styles: the CSS/SASS assets for the project; templates: the pebble templates that are used by Spring at runtime to render a page. We'll loop back around to use the scripts and styles in a little bit, but for now, let's dig in to the templates directory further: Inside the templates directory we have some subdirectories. layouts: the core layouts used by our site to share core functionality and - well - layout; pages: by convention, we put standalone pages in the pages directory. We recommend structuring the directories roughly like the URL path these things will end up on, but there's no reason that you have to; components: snippets and pebble macros that are shared across the project. These generally aren't rendered solo, but we do sometimes do so for e.g. a modal; errors: in this directory we put standard templates for Spring to fall back on when it encounters certain HTTP error codes. Adding a new page Now that we've walked through where everything lives, let's add a \"Hello World\" page. First we create a hello.peb file in the pages directory, with content: {% extends 'layouts/base' %} {% block 'body' %} <h1>Hello World!</h1> {% endblock %} Here, we're using the layouts/base.peb layout and passing in our title element to the body block. If you go to the base layout you'll see a snippet like this: <body> {% block body %}{% endblock %} </body> This means that anything that extends the base layout can add a block to insert its own content into the layout. Now, let's add a Spring Controller endpoint to actually serve this page. In the PublicController class (src/main/kotlin/org/koil/public/PublicController.kt), add a new controller endpoint that renders this template: @GetMapping ( \"/hello\" ) fun hello (): ModelAndView { return ModelAndView ( \"pages/hello\" ) } And navigate to your running application at (http://localhost:8080/hello) to see the page. It works! This is all you have to do to have a page load. Next up is some style. Adding some styles By default, koil uses bulma . Bulma is a css framework that gives a bunch of nice utilities out of the box. Let's make use of some of these bulma CSS classes. Our hello.peb file now looks like: {% extends 'layouts/base' %} {% block 'body' %} <div class=\"container\"> <div class=\"content\"> <h1 class=\"title is-size-1 has-text-centered\">Hello World!</h1> </div> </div> {% endblock %} If you reload the page you'll see something quite different! Remember, you'll have to rebuild the project for Spring to pick up the template update (Ctrl+F9 in IntelliJ). To see how custom styles work, let's take a look at base.peb . We can see in this file that we pull in another stylesheet: < link rel = \"stylesheet\" type = \"text/css\" href = \"/styles/dashboard.scss\" data-turbolinks-track = \"reload\" > Any time we have a href start with \"/\" in koil, it's in reference to the base webapp source at src/webapp/src/ . If we navigate to src/webapp/src/styles/dashboard.scss we'll see that we have a file with a bunch of styles already defined. Let's add our own to the bottom: .hello-title { color : red ! important ; } And apply it in our hello.peb file: {% extends 'layouts/base' %} {% block 'body' %} <div class=\"container\"> <div class=\"content\"> <h1 class=\"title hello-title is-size-1 has-text-centered\">Hello World!</h1> </div> </div> {% endblock %} You can see we've added the hello-title class to our h1 element. And it works! The title is now red. We have the ability to add custom styles. Custom scripts Now let's walk through adding a little javascript. We want to add a button that will change the color of the title between black and red. First, let's take a look at base.peb again to see if there's something that helps us here. We notice the line: < script type = \"text/javascript\" src = \"/scripts/app.js\" defer data-turbolinks-track = \"reload\" ></ script > Navigating to this file like before, we see that it's a fairly standard ES5 file pulling in the dependencies we need. The one we're interested in is import './application.js . Looking at this file, we'll see a bunch of Controller classes being imported and added to a StimulusJS application. If you've never used stimulus before then I'd recommend going through their handbook . Alright, let's add our own Controller to these. Create a file called hello_controller.js in the controllers directory. In this file, we'll add: import { Controller } from \"@stimulus/core\" ; export default class HelloController extends Controller { static get targets () { return [ 'title' ]; } toggleStyle () { this . titleTarget . classList . toggle ( 'hello-title' ) } } And hook it into the application in application.js , by adding an import at the top: import HelloController from \"./controllers/hello_controller\" ; And a registration at the bottom: application . register ( \"hello\" , HelloController ); We'll also need to update our hello.peb file to reflect this: {% extends 'layouts/base' %} {% block 'body' %} <div class=\"container\"> <div class=\"content\" data-controller=\"hello\"> <h1 class=\"title hello-title is-size-1 has-text-centered\" data-target=\"hello.title\">Hello World!</h1> <button type=\"button\" class=\"button\" data-action=\"click->hello#toggleStyle\">Toggle</button> </div> </div> {% endblock %} Re-build the project and... success! When we click the button it toggles the .hello-title style so that it changes colour. There are a couple of changes in hello.peb that I'd like to draw your attention to: We've added a data-controller=\"hello\" attribute to the div on the second line. This will let Stimulus know that it should create a HelloController instance and connect it to this DOM element. We've added a data-target=\"hello.title\" attribute to the h1 tag. This tells Stimulus to treat this DOM element as the this.titleTarget field we made use of in our controller. We've added a data-action=\"click-hello#toggleStyle\" on our button . This tells Stimulus to listen for a click event on this button and to execute the toggleStyle method in our HelloController when it does. Once again, this isn't intended to be a tutorial around Stimulus (we wrote one here ), so we're not going to go into it any further right now. Summary So we've worked through the process of adding a new page with styles and scripts to the project. In the next tutorial, we'll add a form to this page and hook it in to the database.","title":"How to add a static page"},{"location":"tutorials/static/#adding-a-static-ish-page","text":"koil has a pretty funky setup. We're using node to build web things that are then rendered/served with Spring Boot. As a result there are two ways to think about adding a static - or mostly static - page. We can either: * add a document as a fully static document in HTML; or * we can add a template that doesn't rely on a model and render it using Spring. While the former is a little easier, I'd recommend always going for the latter. It lets you use the same template engine, which means you get to leverage the same layout as the rest of your site. It also allows you to leverage the live reload functionality when working in the dev profile.","title":"Adding a static-ish page"},{"location":"tutorials/static/#adding-a-new-template-to-the-project","text":"","title":"Adding a new template to the project"},{"location":"tutorials/static/#project-structure","text":"Almost all front-end assets are held in the src/webapp directory. If you dig into that directory you'll see a setup like so: So underneath the src/webapp directory we have a pretty standard NodeJs project layout. The src directory inside this project is what we're interested in right now. Let's run through what these directories represent: scripts: the javascript and typescript we're using in our project; styles: the CSS/SASS assets for the project; templates: the pebble templates that are used by Spring at runtime to render a page. We'll loop back around to use the scripts and styles in a little bit, but for now, let's dig in to the templates directory further: Inside the templates directory we have some subdirectories. layouts: the core layouts used by our site to share core functionality and - well - layout; pages: by convention, we put standalone pages in the pages directory. We recommend structuring the directories roughly like the URL path these things will end up on, but there's no reason that you have to; components: snippets and pebble macros that are shared across the project. These generally aren't rendered solo, but we do sometimes do so for e.g. a modal; errors: in this directory we put standard templates for Spring to fall back on when it encounters certain HTTP error codes.","title":"Project structure"},{"location":"tutorials/static/#adding-a-new-page","text":"Now that we've walked through where everything lives, let's add a \"Hello World\" page. First we create a hello.peb file in the pages directory, with content: {% extends 'layouts/base' %} {% block 'body' %} <h1>Hello World!</h1> {% endblock %} Here, we're using the layouts/base.peb layout and passing in our title element to the body block. If you go to the base layout you'll see a snippet like this: <body> {% block body %}{% endblock %} </body> This means that anything that extends the base layout can add a block to insert its own content into the layout. Now, let's add a Spring Controller endpoint to actually serve this page. In the PublicController class (src/main/kotlin/org/koil/public/PublicController.kt), add a new controller endpoint that renders this template: @GetMapping ( \"/hello\" ) fun hello (): ModelAndView { return ModelAndView ( \"pages/hello\" ) } And navigate to your running application at (http://localhost:8080/hello) to see the page. It works! This is all you have to do to have a page load. Next up is some style.","title":"Adding a new page"},{"location":"tutorials/static/#adding-some-styles","text":"By default, koil uses bulma . Bulma is a css framework that gives a bunch of nice utilities out of the box. Let's make use of some of these bulma CSS classes. Our hello.peb file now looks like: {% extends 'layouts/base' %} {% block 'body' %} <div class=\"container\"> <div class=\"content\"> <h1 class=\"title is-size-1 has-text-centered\">Hello World!</h1> </div> </div> {% endblock %} If you reload the page you'll see something quite different! Remember, you'll have to rebuild the project for Spring to pick up the template update (Ctrl+F9 in IntelliJ). To see how custom styles work, let's take a look at base.peb . We can see in this file that we pull in another stylesheet: < link rel = \"stylesheet\" type = \"text/css\" href = \"/styles/dashboard.scss\" data-turbolinks-track = \"reload\" > Any time we have a href start with \"/\" in koil, it's in reference to the base webapp source at src/webapp/src/ . If we navigate to src/webapp/src/styles/dashboard.scss we'll see that we have a file with a bunch of styles already defined. Let's add our own to the bottom: .hello-title { color : red ! important ; } And apply it in our hello.peb file: {% extends 'layouts/base' %} {% block 'body' %} <div class=\"container\"> <div class=\"content\"> <h1 class=\"title hello-title is-size-1 has-text-centered\">Hello World!</h1> </div> </div> {% endblock %} You can see we've added the hello-title class to our h1 element. And it works! The title is now red. We have the ability to add custom styles.","title":"Adding some styles"},{"location":"tutorials/static/#custom-scripts","text":"Now let's walk through adding a little javascript. We want to add a button that will change the color of the title between black and red. First, let's take a look at base.peb again to see if there's something that helps us here. We notice the line: < script type = \"text/javascript\" src = \"/scripts/app.js\" defer data-turbolinks-track = \"reload\" ></ script > Navigating to this file like before, we see that it's a fairly standard ES5 file pulling in the dependencies we need. The one we're interested in is import './application.js . Looking at this file, we'll see a bunch of Controller classes being imported and added to a StimulusJS application. If you've never used stimulus before then I'd recommend going through their handbook . Alright, let's add our own Controller to these. Create a file called hello_controller.js in the controllers directory. In this file, we'll add: import { Controller } from \"@stimulus/core\" ; export default class HelloController extends Controller { static get targets () { return [ 'title' ]; } toggleStyle () { this . titleTarget . classList . toggle ( 'hello-title' ) } } And hook it into the application in application.js , by adding an import at the top: import HelloController from \"./controllers/hello_controller\" ; And a registration at the bottom: application . register ( \"hello\" , HelloController ); We'll also need to update our hello.peb file to reflect this: {% extends 'layouts/base' %} {% block 'body' %} <div class=\"container\"> <div class=\"content\" data-controller=\"hello\"> <h1 class=\"title hello-title is-size-1 has-text-centered\" data-target=\"hello.title\">Hello World!</h1> <button type=\"button\" class=\"button\" data-action=\"click->hello#toggleStyle\">Toggle</button> </div> </div> {% endblock %} Re-build the project and... success! When we click the button it toggles the .hello-title style so that it changes colour. There are a couple of changes in hello.peb that I'd like to draw your attention to: We've added a data-controller=\"hello\" attribute to the div on the second line. This will let Stimulus know that it should create a HelloController instance and connect it to this DOM element. We've added a data-target=\"hello.title\" attribute to the h1 tag. This tells Stimulus to treat this DOM element as the this.titleTarget field we made use of in our controller. We've added a data-action=\"click-hello#toggleStyle\" on our button . This tells Stimulus to listen for a click event on this button and to execute the toggleStyle method in our HelloController when it does. Once again, this isn't intended to be a tutorial around Stimulus (we wrote one here ), so we're not going to go into it any further right now.","title":"Custom scripts"},{"location":"tutorials/static/#summary","text":"So we've worked through the process of adding a new page with styles and scripts to the project. In the next tutorial, we'll add a form to this page and hook it in to the database.","title":"Summary"}]}