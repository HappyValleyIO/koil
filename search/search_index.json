{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Springboard These docs are very much a work in progress. You can contribute by going to the repo at the github repo For full documentation visit mkdocs.org .","title":"Welcome to Springboard"},{"location":"#welcome-to-springboard","text":"These docs are very much a work in progress. You can contribute by going to the repo at the github repo For full documentation visit mkdocs.org .","title":"Welcome to Springboard"},{"location":"deploy/heroku/","text":"Deploying to Heroku Heroku is a PaaS product that makes deploying your application easy. With it's generous free tier it's a perfect way to kick off a new project. Springboard works pretty well with Heroku and benefits a fair bit from a number of Heroku add-ons: mailgun as an SMTP server to send emails; sentry for error-tracking; logdna for log aggregation; and hosted postgresql as a data store. You can check the other add-ons heroku comes with out of the box here . Minimum Viable Deployment There are a couple of ways that we can deploy to Heroku - they maintain excellent docs on this here . The deployment mechanism we'll be focusing on is the github integration. We'll be building out a production-ready pipeline here. We'll connect our app to a springboard based github repo and deploy the application with a database. One of the primary benefits to working in Springboard is simplicity of building/deploying. It's a single, stateless JVM instance that's connected to a database. Most of the tricky first-time setup has already been done in the gradle build scripts. As such, anything that can deploy a spring boot project can deploy a springboard project without difficulty. As it happens, Heroku has terrific integration with Spring Boot so deploying a live, production-ready application is pretty simple. I'm going to presume you've signed up to a Heroku account, if you haven't then do so , login to the Heroku dashboard and get ready to go. Step 1: Create a Heroku App If you've just signed up to Heroku you'll be presented with an empty dashboard. On this page, click the New button and select App . This will take you to the create application page: When there fill in the details for your application and hit Create App . This will take you on to your new app page: Hooray! An app is born! Step 2: Create a pipeline and deploy Now, our app doesn't actually do anything yet. Let's fix that. You'll be prompted to add this app to a pipeline at the top of the page. Click to create a new pipeline and fill in the details: This will forward you on to the newly created pipeline: When here, click the prompt to Connect to Github . If you don't see this prompt then navigate to the Settings tab. Once on this page, search for your GitHub repo then connect. While you're here, I'd really recommend enabling review apps . You can see the settings we recommend in the image below: They'll give you a great way to interact with pull request changes before merging. Springboard comes with an app.json file configured that specifies the required postgres database for your review apps. If you'd like to add other addons for each review app, then you can do so by modifying app.json . Heroku will respect the changes on the next deploy. Step 3: Enable automatic deploys Navigate back to the Pipeline tab to see the new setup. We'll add a staging environment here later. For now, let's enable automatic deploys. Click the menu toggle button on the production app. And click Configure automatic deploys... . You'll be presented with some options. We recommend deploying master only after CI passes. And we're set! This means that the next time we merge into master we'll see our application automatically updated! Step 4: Making a change Let's make a tiny change. I've added a new empty line between two tags in src/webapp/src/templates/pages/index.peb . You could do something more dramatic here of course. Commit this change on a feature branch feature/example and push to github. Now go to your repo in the browser and you'll be prompted to open a pull-request. Click the Compare & pull request... button, fill out the form on this page and then create the pull request. Alright! Now go make a cup of coffee while the CI build runs. Springboard has a longer build than a base Spring Boot project, but we promise it's worth it. Right now GitHub is running unit, integration and feature tests on the back-end and has kicked off Cypress to test your front-end. Once it's done you should see something like this: Click the View dpeloyment button and... Ta-da! Our review app is live! This has it's own Heroku Postgres instance spun up so we can play around with it without impacting a shared database. Step 5: Merging to master and deploying to production Now that we've done some QA on our review app, we'll merge the pull request and deploy to production. Normally, this is where a teammate would review our change, but for now we can safely click the Merge button and carry on solo. Upon merging the pull request, the review app instance will be spun down - saving us some money/free dyno hours. At this point you can head back to the heroku pipeline to view the deploy logs. Give it a couple of minutes to run and your app will be deployed! You can also check in on the deployment in the GitHub environment screen, by clicking the environments button on your repo's home page. Once the app has been deployed this will change to read Deployed . Click the View deployment button... and it's broken! This is because Heroku doesn't respect the app.json file's addons in production. I don't fully understand why they made this choice, but let's fix it. Step 6: Spinning up the production database Navigate over to the application in Heroku and go to the resources tab: And provision a free database: Now click More at the top right and Restart all dynos . Now - after the restart completes - we can try clicking Open App again... Success! Our app is now live in production! Step 7: reflect on the result To conclude, we now have: an automated process that runs all of our tests for a pull request; on test success deploys the pull request code to a unique, isolated environment; on merge deletes the review application automatically; and deploys the change to production. This is incredibly powerful. Whether you're working solo or in a team, I think having a way to easily review and trial changes before letting a customer get access to them is the way forward. There's more yet to do though! Continue on below to allow your application to send email, report errors to sentry and to have a long-lived staging environment for QA. Adding mailgun TODO Adding Staging TODO Adding Sentry TODO Adding LogDNA","title":"Deploy to Heroku"},{"location":"deploy/heroku/#deploying-to-heroku","text":"Heroku is a PaaS product that makes deploying your application easy. With it's generous free tier it's a perfect way to kick off a new project. Springboard works pretty well with Heroku and benefits a fair bit from a number of Heroku add-ons: mailgun as an SMTP server to send emails; sentry for error-tracking; logdna for log aggregation; and hosted postgresql as a data store. You can check the other add-ons heroku comes with out of the box here .","title":"Deploying to Heroku"},{"location":"deploy/heroku/#minimum-viable-deployment","text":"There are a couple of ways that we can deploy to Heroku - they maintain excellent docs on this here . The deployment mechanism we'll be focusing on is the github integration. We'll be building out a production-ready pipeline here. We'll connect our app to a springboard based github repo and deploy the application with a database. One of the primary benefits to working in Springboard is simplicity of building/deploying. It's a single, stateless JVM instance that's connected to a database. Most of the tricky first-time setup has already been done in the gradle build scripts. As such, anything that can deploy a spring boot project can deploy a springboard project without difficulty. As it happens, Heroku has terrific integration with Spring Boot so deploying a live, production-ready application is pretty simple. I'm going to presume you've signed up to a Heroku account, if you haven't then do so , login to the Heroku dashboard and get ready to go.","title":"Minimum Viable Deployment"},{"location":"deploy/heroku/#step-1-create-a-heroku-app","text":"If you've just signed up to Heroku you'll be presented with an empty dashboard. On this page, click the New button and select App . This will take you to the create application page: When there fill in the details for your application and hit Create App . This will take you on to your new app page: Hooray! An app is born!","title":"Step 1: Create a Heroku App"},{"location":"deploy/heroku/#step-2-create-a-pipeline-and-deploy","text":"Now, our app doesn't actually do anything yet. Let's fix that. You'll be prompted to add this app to a pipeline at the top of the page. Click to create a new pipeline and fill in the details: This will forward you on to the newly created pipeline: When here, click the prompt to Connect to Github . If you don't see this prompt then navigate to the Settings tab. Once on this page, search for your GitHub repo then connect. While you're here, I'd really recommend enabling review apps . You can see the settings we recommend in the image below: They'll give you a great way to interact with pull request changes before merging. Springboard comes with an app.json file configured that specifies the required postgres database for your review apps. If you'd like to add other addons for each review app, then you can do so by modifying app.json . Heroku will respect the changes on the next deploy.","title":"Step 2: Create a pipeline and deploy"},{"location":"deploy/heroku/#step-3-enable-automatic-deploys","text":"Navigate back to the Pipeline tab to see the new setup. We'll add a staging environment here later. For now, let's enable automatic deploys. Click the menu toggle button on the production app. And click Configure automatic deploys... . You'll be presented with some options. We recommend deploying master only after CI passes. And we're set! This means that the next time we merge into master we'll see our application automatically updated!","title":"Step 3: Enable automatic deploys"},{"location":"deploy/heroku/#step-4-making-a-change","text":"Let's make a tiny change. I've added a new empty line between two tags in src/webapp/src/templates/pages/index.peb . You could do something more dramatic here of course. Commit this change on a feature branch feature/example and push to github. Now go to your repo in the browser and you'll be prompted to open a pull-request. Click the Compare & pull request... button, fill out the form on this page and then create the pull request. Alright! Now go make a cup of coffee while the CI build runs. Springboard has a longer build than a base Spring Boot project, but we promise it's worth it. Right now GitHub is running unit, integration and feature tests on the back-end and has kicked off Cypress to test your front-end. Once it's done you should see something like this: Click the View dpeloyment button and... Ta-da! Our review app is live! This has it's own Heroku Postgres instance spun up so we can play around with it without impacting a shared database.","title":"Step 4: Making a change"},{"location":"deploy/heroku/#step-5-merging-to-master-and-deploying-to-production","text":"Now that we've done some QA on our review app, we'll merge the pull request and deploy to production. Normally, this is where a teammate would review our change, but for now we can safely click the Merge button and carry on solo. Upon merging the pull request, the review app instance will be spun down - saving us some money/free dyno hours. At this point you can head back to the heroku pipeline to view the deploy logs. Give it a couple of minutes to run and your app will be deployed! You can also check in on the deployment in the GitHub environment screen, by clicking the environments button on your repo's home page. Once the app has been deployed this will change to read Deployed . Click the View deployment button... and it's broken! This is because Heroku doesn't respect the app.json file's addons in production. I don't fully understand why they made this choice, but let's fix it.","title":"Step 5: Merging to master and deploying to production"},{"location":"deploy/heroku/#step-6-spinning-up-the-production-database","text":"Navigate over to the application in Heroku and go to the resources tab: And provision a free database: Now click More at the top right and Restart all dynos . Now - after the restart completes - we can try clicking Open App again... Success! Our app is now live in production!","title":"Step 6: Spinning up the production database"},{"location":"deploy/heroku/#step-7-reflect-on-the-result","text":"To conclude, we now have: an automated process that runs all of our tests for a pull request; on test success deploys the pull request code to a unique, isolated environment; on merge deletes the review application automatically; and deploys the change to production. This is incredibly powerful. Whether you're working solo or in a team, I think having a way to easily review and trial changes before letting a customer get access to them is the way forward. There's more yet to do though! Continue on below to allow your application to send email, report errors to sentry and to have a long-lived staging environment for QA.","title":"Step 7: reflect on the result"},{"location":"deploy/heroku/#adding-mailgun","text":"TODO","title":"Adding mailgun"},{"location":"deploy/heroku/#adding-staging","text":"TODO","title":"Adding Staging"},{"location":"deploy/heroku/#adding-sentry","text":"TODO","title":"Adding Sentry"},{"location":"deploy/heroku/#adding-logdna","text":"","title":"Adding LogDNA"},{"location":"tutorials/static/","text":"Adding a static-ish page Springboard has a pretty funky setup. We're using node to build web things that are then rendered/served with Spring Boot. As a result there are two ways to think about adding a static - or mostly static - page. We can either: * add a document as a fully static document in HTML; or * we can add a template that doesn't rely on a model and render it using Spring. While the former is a little easier, I'd recommend always going for the latter. It lets you use the same template engine, which means you get to leverage the same layout as the rest of your site. It also allows you to leverage the live reload functionality when working in the dev profile. Adding a new template to the project Project structure Almost all front-end assets are held in the src/webapp directory. If you dig into that directory you'll see a setup like so: So underneath the src/webapp directory we have a pretty standard NodeJs project layout. The src directory inside this project is what we're interested in right now. Let's run through what these directories represent: scripts: the javascript and typescript we're using in our project; styles: the CSS/SASS assets for the project; templates: the pebble templates that are used by Spring at runtime to render a page. We'll loop back around to use the scripts and styles in a little bit, but for now, let's dig in to the templates directory further: Inside the templates directory we have some subdirectories. layouts: the core layouts used by our site to share core functionality and - well - layout; pages: by convention, we put standalone pages in the pages directory. We recommend structuring the directories roughly like the URL path these things will end up on, but there's no reason that you have to; components: snippets and pebble macros that are shared across the project. These generally aren't rendered solo, but we do sometimes do so for e.g. a modal; errors: in this directory we put standard templates for Spring to fall back on when it encounters certain HTTP error codes. Adding a new page Now that we've walked through where everything lives, let's add a \"Hello World\" page. First we create a hello.peb file in the pages directory, with content: {% extends 'layouts/base' %} {% block 'body' %} <h1>Hello World!</h1> {% endblock %} Here, we're using the layouts/base.peb layout and passing in our title element to the body block. If you go to the base layout you'll see a snippet like this: <body> {% block body %}{% endblock %} </body> This means that anything that extends the base layout can add a block to insert its own content into the layout. Now, let's add a Spring Controller endpoint to actually serve this page. In the PublicController class (src/main/kotlin/org/springboard/public/PublicController.kt), add a new controller endpoint that renders this template: @GetMapping ( \"/hello\" ) fun hello (): ModelAndView { return ModelAndView ( \"pages/hello\" ) } And navigate to your running application at (http://localhost:8080/hello) to see the page. It works! This is all you have to do to have a page load. Next up is some style. Adding some styles By default, Springboard uses bulma . Bulma is a css framework that gives a bunch of nice utilities out of the box. Let's make use of some of these bulma CSS classes. Our hello.peb file now looks like: {% extends 'layouts/base' %} {% block 'body' %} <div class=\"container\"> <div class=\"content\"> <h1 class=\"title is-size-1 has-text-centered\">Hello World!</h1> </div> </div> {% endblock %} If you reload the page you'll see something quite different! Remember, you'll have to rebuild the project for Spring to pick up the template update (Ctrl+F9 in IntelliJ). To see how custom styles work, let's take a look at base.peb . We can see in this file that we pull in another stylesheet: < link rel = \"stylesheet\" type = \"text/css\" href = \"/styles/dashboard.scss\" data-turbolinks-track = \"reload\" > Any time we have a href start with \"/\" in Springboard, it's in reference to the base webapp source at src/webapp/src/ . If we navigate to src/webapp/src/styles/dashboard.scss we'll see that we have a file with a bunch of styles already defined. Let's add our own to the bottom: .hello-title { color : red ! important ; } And apply it in our hello.peb file: {% extends 'layouts/base' %} {% block 'body' %} <div class=\"container\"> <div class=\"content\"> <h1 class=\"title hello-title is-size-1 has-text-centered\">Hello World!</h1> </div> </div> {% endblock %} You can see we've added the hello-title class to our h1 element. And it works! The title is now red. We have the ability to add custom styles. Custom scripts Now let's walk through adding a little javascript. We want to add a button that will change the color of the title between black and red. First, let's take a look at base.peb again to see if there's something that helps us here. We notice the line: < script type = \"text/javascript\" src = \"/scripts/app.js\" defer data-turbolinks-track = \"reload\" ></ script > Navigating to this file like before, we see that it's a fairly standard ES5 file pulling in the dependencies we need. The one we're interested in is import './application.js . Looking at this file, we'll see a bunch of Controller classes being imported and added to a StimulusJS application. If you've never used stimulus before then I'd recommend going through their handbook . Alright, let's add our own Controller to these. Create a file called hello_controller.js in the controllers directory. In this file, we'll add: import { Controller } from \"@stimulus/core\" ; export default class HelloController extends Controller { static get targets () { return [ 'title' ]; } toggleStyle () { this . titleTarget . classList . toggle ( 'hello-title' ) } } And hook it into the application in application.js , by adding an import at the top: import HelloController from \"./controllers/hello_controller\" ; And a registration at the bottom: application . register ( \"hello\" , HelloController ); We'll also need to update our hello.peb file to reflect this: {% extends 'layouts/base' %} {% block 'body' %} <div class=\"container\"> <div class=\"content\" data-controller=\"hello\"> <h1 class=\"title hello-title is-size-1 has-text-centered\" data-target=\"hello.title\">Hello World!</h1> <button type=\"button\" class=\"button\" data-action=\"click->hello#toggleStyle\">Toggle</button> </div> </div> {% endblock %} Re-build the project and... success! When we click the button it toggles the .hello-title style so that it changes colour. There are a couple of changes in hello.peb that I'd like to draw your attention to: We've added a data-controller=\"hello\" attribute to the div on the second line. This will let Stimulus know that it should create a HelloController instance and connect it to this DOM element. We've added a data-target=\"hello.title\" attribute to the h1 tag. This tells Stimulus to treat this DOM element as the this.titleTarget field we made use of in our controller. We've added a data-action=\"click-hello#toggleStyle\" on our button . This tells Stimulus to listen for a click event on this button and to execute the toggleStyle method in our HelloController when it does. Once again, this isn't intended to be a tutorial around Stimulus (we wrote one here ), so we're not going to go into it any further right now. Summary So we've worked through the process of adding a new page with styles and scripts to the project. In the next tutorial, we'll add a form to this page and hook it in to the database.","title":"How to add a static page"},{"location":"tutorials/static/#adding-a-static-ish-page","text":"Springboard has a pretty funky setup. We're using node to build web things that are then rendered/served with Spring Boot. As a result there are two ways to think about adding a static - or mostly static - page. We can either: * add a document as a fully static document in HTML; or * we can add a template that doesn't rely on a model and render it using Spring. While the former is a little easier, I'd recommend always going for the latter. It lets you use the same template engine, which means you get to leverage the same layout as the rest of your site. It also allows you to leverage the live reload functionality when working in the dev profile.","title":"Adding a static-ish page"},{"location":"tutorials/static/#adding-a-new-template-to-the-project","text":"","title":"Adding a new template to the project"},{"location":"tutorials/static/#project-structure","text":"Almost all front-end assets are held in the src/webapp directory. If you dig into that directory you'll see a setup like so: So underneath the src/webapp directory we have a pretty standard NodeJs project layout. The src directory inside this project is what we're interested in right now. Let's run through what these directories represent: scripts: the javascript and typescript we're using in our project; styles: the CSS/SASS assets for the project; templates: the pebble templates that are used by Spring at runtime to render a page. We'll loop back around to use the scripts and styles in a little bit, but for now, let's dig in to the templates directory further: Inside the templates directory we have some subdirectories. layouts: the core layouts used by our site to share core functionality and - well - layout; pages: by convention, we put standalone pages in the pages directory. We recommend structuring the directories roughly like the URL path these things will end up on, but there's no reason that you have to; components: snippets and pebble macros that are shared across the project. These generally aren't rendered solo, but we do sometimes do so for e.g. a modal; errors: in this directory we put standard templates for Spring to fall back on when it encounters certain HTTP error codes.","title":"Project structure"},{"location":"tutorials/static/#adding-a-new-page","text":"Now that we've walked through where everything lives, let's add a \"Hello World\" page. First we create a hello.peb file in the pages directory, with content: {% extends 'layouts/base' %} {% block 'body' %} <h1>Hello World!</h1> {% endblock %} Here, we're using the layouts/base.peb layout and passing in our title element to the body block. If you go to the base layout you'll see a snippet like this: <body> {% block body %}{% endblock %} </body> This means that anything that extends the base layout can add a block to insert its own content into the layout. Now, let's add a Spring Controller endpoint to actually serve this page. In the PublicController class (src/main/kotlin/org/springboard/public/PublicController.kt), add a new controller endpoint that renders this template: @GetMapping ( \"/hello\" ) fun hello (): ModelAndView { return ModelAndView ( \"pages/hello\" ) } And navigate to your running application at (http://localhost:8080/hello) to see the page. It works! This is all you have to do to have a page load. Next up is some style.","title":"Adding a new page"},{"location":"tutorials/static/#adding-some-styles","text":"By default, Springboard uses bulma . Bulma is a css framework that gives a bunch of nice utilities out of the box. Let's make use of some of these bulma CSS classes. Our hello.peb file now looks like: {% extends 'layouts/base' %} {% block 'body' %} <div class=\"container\"> <div class=\"content\"> <h1 class=\"title is-size-1 has-text-centered\">Hello World!</h1> </div> </div> {% endblock %} If you reload the page you'll see something quite different! Remember, you'll have to rebuild the project for Spring to pick up the template update (Ctrl+F9 in IntelliJ). To see how custom styles work, let's take a look at base.peb . We can see in this file that we pull in another stylesheet: < link rel = \"stylesheet\" type = \"text/css\" href = \"/styles/dashboard.scss\" data-turbolinks-track = \"reload\" > Any time we have a href start with \"/\" in Springboard, it's in reference to the base webapp source at src/webapp/src/ . If we navigate to src/webapp/src/styles/dashboard.scss we'll see that we have a file with a bunch of styles already defined. Let's add our own to the bottom: .hello-title { color : red ! important ; } And apply it in our hello.peb file: {% extends 'layouts/base' %} {% block 'body' %} <div class=\"container\"> <div class=\"content\"> <h1 class=\"title hello-title is-size-1 has-text-centered\">Hello World!</h1> </div> </div> {% endblock %} You can see we've added the hello-title class to our h1 element. And it works! The title is now red. We have the ability to add custom styles.","title":"Adding some styles"},{"location":"tutorials/static/#custom-scripts","text":"Now let's walk through adding a little javascript. We want to add a button that will change the color of the title between black and red. First, let's take a look at base.peb again to see if there's something that helps us here. We notice the line: < script type = \"text/javascript\" src = \"/scripts/app.js\" defer data-turbolinks-track = \"reload\" ></ script > Navigating to this file like before, we see that it's a fairly standard ES5 file pulling in the dependencies we need. The one we're interested in is import './application.js . Looking at this file, we'll see a bunch of Controller classes being imported and added to a StimulusJS application. If you've never used stimulus before then I'd recommend going through their handbook . Alright, let's add our own Controller to these. Create a file called hello_controller.js in the controllers directory. In this file, we'll add: import { Controller } from \"@stimulus/core\" ; export default class HelloController extends Controller { static get targets () { return [ 'title' ]; } toggleStyle () { this . titleTarget . classList . toggle ( 'hello-title' ) } } And hook it into the application in application.js , by adding an import at the top: import HelloController from \"./controllers/hello_controller\" ; And a registration at the bottom: application . register ( \"hello\" , HelloController ); We'll also need to update our hello.peb file to reflect this: {% extends 'layouts/base' %} {% block 'body' %} <div class=\"container\"> <div class=\"content\" data-controller=\"hello\"> <h1 class=\"title hello-title is-size-1 has-text-centered\" data-target=\"hello.title\">Hello World!</h1> <button type=\"button\" class=\"button\" data-action=\"click->hello#toggleStyle\">Toggle</button> </div> </div> {% endblock %} Re-build the project and... success! When we click the button it toggles the .hello-title style so that it changes colour. There are a couple of changes in hello.peb that I'd like to draw your attention to: We've added a data-controller=\"hello\" attribute to the div on the second line. This will let Stimulus know that it should create a HelloController instance and connect it to this DOM element. We've added a data-target=\"hello.title\" attribute to the h1 tag. This tells Stimulus to treat this DOM element as the this.titleTarget field we made use of in our controller. We've added a data-action=\"click-hello#toggleStyle\" on our button . This tells Stimulus to listen for a click event on this button and to execute the toggleStyle method in our HelloController when it does. Once again, this isn't intended to be a tutorial around Stimulus (we wrote one here ), so we're not going to go into it any further right now.","title":"Custom scripts"},{"location":"tutorials/static/#summary","text":"So we've worked through the process of adding a new page with styles and scripts to the project. In the next tutorial, we'll add a form to this page and hook it in to the database.","title":"Summary"}]}